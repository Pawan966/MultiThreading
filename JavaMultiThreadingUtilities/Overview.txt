Lock Interface:
Simply put, a lock is a more flexible and sophisticated thread synchronization mechanism than the standard synchronized block.
Let’s take a look at the methods in the Lock interface:
1. void lock() – Acquire the lock if it’s available. If the lock isn’t available, a thread gets blocked until the lock is released.
2. void lockInterruptibly() – This is similar to the lock(), but it allows the blocked thread to be interrupted and resume the execution through a thrown java.lang.InterruptedException.
3. boolean tryLock() – This is a nonblocking version of lock() method. It attempts to acquire the lock immediately, return true if locking succeeds.
4. boolean tryLock(long timeout, TimeUnit timeUnit) – This is similar to tryLock(), except it waits up the given timeout before giving up trying to acquire the Lock.
5. void unlock() - This unlocks the Lock instance.

Differences Between Lock and Synchronized Block:
1. A thread gets blocked if it can’t get an access to the synchronized block.
   The Lock API provides tryLock() method. The thread acquires lock only if it’s available and not held by any other thread.
   This reduces blocking time of thread waiting for the lock.
2. A thread that is in “waiting” state to acquire the access to synchronized block can’t be interrupted.
   The Lock API provides a method lockInterruptibly() that can be used to interrupt the thread when it’s waiting for the lock.
3. A synchronized block doesn’t support the fairness. Any thread can acquire the lock once released, and no preference can be specified.
   We can achieve fairness within the Lock APIs by specifying the fairness property.
